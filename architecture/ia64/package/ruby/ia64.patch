# --- T2-COPYRIGHT-NOTE-BEGIN ---
# T2 SDE: architecture/ia64/package/*/ia64.patch
# Copyright (C) 2024 The T2 SDE Project
# 
# This Copyright note is generated by scripts/Create-CopyPatch,
# more information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License version 2 as used by the T2 SDE.
# --- T2-COPYRIGHT-NOTE-END ---

Revert ia64 removal d17344cfc56edc4599252041b3ec0d46af0851fd

miniruby crashes though, except when run in gdb, yay, likely
native fiber related: 6c6bf9ffcbfeb8be9d9c342e7604b74ec819e88a

diff -urN --exclude '*orig' ruby-3.1.5/common.mk ruby-3.1.5-ia64/common.mk
--- ruby-3.1.5/common.mk	2024-04-23 12:20:59.000000000 +0200
+++ ruby-3.1.5-ia64/common.mk	2024-05-30 11:24:24.908189690 +0200
@@ -997,6 +997,8 @@
 strlcpy.$(OBJEXT): {$(VPATH)}strlcpy.c
 strstr.$(OBJEXT): {$(VPATH)}strstr.c
 tgamma.$(OBJEXT): {$(VPATH)}tgamma.c
+ia64.$(OBJEXT): {$(VPATH)}ia64.s
+	$(CC) $(CFLAGS) -c $<
 
 .coroutine_obj $(COROUTINE_OBJ): \
 	{$(VPATH)}$(COROUTINE_SRC) \
diff -urN --exclude '*orig' ruby-3.1.5/configure.ac ruby-3.1.5-ia64/configure.ac
--- ruby-3.1.5/configure.ac	2024-04-23 12:20:59.000000000 +0200
+++ ruby-3.1.5-ia64/configure.ac	2024-05-30 11:18:37.540127727 +0200
@@ -1935,6 +1935,24 @@
 ])
 AC_FUNC_MEMCMP
 
+# http://sources.redhat.com/ml/libc-hacker/2005-08/msg00008.html
+# Debian GNU/Linux Etch's libc6.1 2.3.6.ds1-13etch5 has this problem.
+# Debian GNU/Linux Lenny's libc6.1 2.7-10 has no problem.
+AC_CACHE_CHECK(for broken erfc of glibc-2.3.6 on IA64, rb_cv_broken_glibc_ia64_erfc,
+  [AC_TRY_RUN([
+#include <math.h>
+int
+main()
+{
+   erfc(10000.0);
+   return 0;
+}
+],
+	rb_cv_broken_glibc_ia64_erfc=no,
+	rb_cv_broken_glibc_ia64_erfc=yes,
+	rb_cv_broken_glibc_ia64_erfc=no)])
+AS_CASE([$rb_cv_broken_glibc_ia64_erfc],[yes],[ac_cv_func_erf=no])
+
 AS_CASE(["$target_os"],[freebsd*],[
 	 AC_DEFINE(BROKEN_CLOSE)
 	 AC_REPLACE_FUNCS(close)
@@ -2452,6 +2470,21 @@
 ])])
 ])
 
+AS_IF([test x"$target_cpu" = xia64], [
+    AC_LIBOBJ([ia64])
+    AC_CACHE_CHECK(for __libc_ia64_register_backing_store_base,
+                   rb_cv___libc_ia64_register_backing_store_base,
+    [rb_cv___libc_ia64_register_backing_store_base=no
+    AC_TRY_LINK(
+      [extern unsigned long __libc_ia64_register_backing_store_base;],
+      [unsigned long p = __libc_ia64_register_backing_store_base;
+       printf("%ld\n", p);],
+      [rb_cv___libc_ia64_register_backing_store_base=yes])])
+    AS_IF([test $rb_cv___libc_ia64_register_backing_store_base = yes], [
+      AC_DEFINE(HAVE___LIBC_IA64_REGISTER_BACKING_STORE_BASE)
+    ])
+])
+
 AC_CACHE_CHECK(whether right shift preserve sign bit, rb_cv_rshift_sign,
     [AC_COMPILE_IFELSE([AC_LANG_BOOL_COMPILE_TRY([], [(-1==(-1>>1))])],
 	rb_cv_rshift_sign=yes,
diff -urN --exclude '*orig' ruby-3.1.5/cont.c ruby-3.1.5-ia64/cont.c
--- ruby-3.1.5/cont.c	2024-04-23 12:20:59.000000000 +0200
+++ ruby-3.1.5-ia64/cont.c	2024-05-30 11:28:52.676237454 +0200
@@ -204,6 +204,11 @@
         VALUE *stack;
         VALUE *stack_src;
         size_t stack_size;
+#ifdef __ia64
+       VALUE *register_stack;
+       VALUE *register_stack_src;
+       int register_stack_size;
+#endif
     } machine;
     rb_execution_context_t saved_ec;
     rb_jmpbuf_t jmpbuf;
@@ -373,6 +378,12 @@
     if (vacancy) {
         fiber_pool_vacancy_remove(vacancy);
     }
+#ifdef __ia64
+    if (cont->machine.register_stack) {
+	rb_gc_mark_locations(cont->machine.register_stack,
+			     cont->machine.register_stack + cont->machine.register_stack_size);
+    }
+#endif
 
     return vacancy;
 }
@@ -798,6 +809,10 @@
     sec->machine.stack_start = fiber->stack.current;
     sec->machine.stack_maxsize = fiber->stack.available;
 
+#ifdef __ia64
+    sec->machine.register_stack_maxsize = sec->machine.stack_maxsize;
+#endif
+
     fiber->context.argument = (void*)fiber;
 
     return vm_stack;
@@ -988,6 +1003,9 @@
         fiber_stack_release(fiber);
     }
 
+#ifdef __ia64
+    RUBY_FREE_UNLESS_NULL(cont->machine.register_stack);
+#endif
     RUBY_FREE_UNLESS_NULL(cont->saved_vm_stack.ptr);
 
     if (mjit_enabled) {
@@ -1018,7 +1036,11 @@
     if (cont->machine.stack) {
         size += cont->machine.stack_size * sizeof(*cont->machine.stack);
     }
-
+#ifdef __ia64
+    if (cont->machine.register_stack) {
+	size += cont->machine.register_stack_size * sizeof(*cont->machine.register_stack);
+    }
+#endif
     return size;
 }
 
@@ -1114,6 +1136,9 @@
     size_t size;
 
     SET_MACHINE_STACK_END(&th->ec->machine.stack_end);
+#ifdef __ia64
+    th->ec->machine.register_stack_end = rb_ia64_bsp();
+#endif
 
     if (th->ec->machine.stack_start > th->ec->machine.stack_end) {
         size = cont->machine.stack_size = th->ec->machine.stack_start - th->ec->machine.stack_end;
@@ -1133,6 +1158,20 @@
 
     FLUSH_REGISTER_WINDOWS;
     MEMCPY(cont->machine.stack, cont->machine.stack_src, VALUE, size);
+
+#ifdef __ia64
+    rb_ia64_flushrs();
+    size = cont->machine.register_stack_size = th->ec->machine.register_stack_end - th->ec->machine.register_stack_start;
+    cont->machine.register_stack_src = th->ec->machine.register_stack_start;
+    if (cont->machine.register_stack) {
+	REALLOC_N(cont->machine.register_stack, VALUE, size);
+    }
+    else {
+	cont->machine.register_stack = ALLOC_N(VALUE, size);
+    }
+
+    MEMCPY(cont->machine.register_stack, cont->machine.register_stack_src, VALUE, size);
+#endif
 }
 
 static const rb_data_type_t cont_data_type = {
@@ -1154,6 +1193,10 @@
     /* saved_ec->machine.stack_end should be NULL */
     /* because it may happen GC afterward */
     sec->machine.stack_end = NULL;
+
+#ifdef __ia64
+    sec->machine.register_stack_end = NULL;
+#endif
 }
 
 static void
@@ -1428,11 +1471,53 @@
                VALUE, cont->machine.stack_size);
     }
 
+#ifdef __ia64
+    if (cont->machine.register_stack_src) {
+	MEMCPY(cont->machine.register_stack_src, cont->machine.register_stack,
+	       VALUE, cont->machine.register_stack_size);
+    }
+#endif
+
     ruby_longjmp(cont->jmpbuf, 1);
 }
 
 NORETURN(NOINLINE(static void cont_restore_0(rb_context_t *, VALUE *)));
 
+#ifdef __ia64
+#define C(a) rse_##a##0, rse_##a##1, rse_##a##2, rse_##a##3, rse_##a##4
+#define E(a) rse_##a##0= rse_##a##1= rse_##a##2= rse_##a##3= rse_##a##4
+static volatile int C(a), C(b), C(c), C(d), C(e);
+static volatile int C(f), C(g), C(h), C(i), C(j);
+static volatile int C(k), C(l), C(m), C(n), C(o);
+static volatile int C(p), C(q), C(r), C(s), C(t);
+#if 0
+{/* the above lines make cc-mode.el confused so much */}
+#endif
+int rb_dummy_false = 0;
+NORETURN(NOINLINE(static void register_stack_extend(rb_context_t *, VALUE *, VALUE *)));
+static void
+register_stack_extend(rb_context_t *cont, VALUE *vp, VALUE *curr_bsp)
+{
+    if (rb_dummy_false) {
+        /* use registers as much as possible */
+        E(a) = E(b) = E(c) = E(d) = E(e) =
+        E(f) = E(g) = E(h) = E(i) = E(j) =
+        E(k) = E(l) = E(m) = E(n) = E(o) =
+        E(p) = E(q) = E(r) = E(s) = E(t) = 0;
+        E(a) = E(b) = E(c) = E(d) = E(e) =
+        E(f) = E(g) = E(h) = E(i) = E(j) =
+        E(k) = E(l) = E(m) = E(n) = E(o) =
+        E(p) = E(q) = E(r) = E(s) = E(t) = 0;
+    }
+    if (curr_bsp < cont->machine.register_stack_src+cont->machine.register_stack_size) {
+        register_stack_extend(cont, vp, (VALUE*)rb_ia64_bsp());
+    }
+    cont_restore_0(cont, vp);
+}
+#undef C
+#undef E
+#endif
+
 static void
 cont_restore_0(rb_context_t *cont, VALUE *addr_in_prev_frame)
 {
@@ -1481,6 +1566,9 @@
     }
     cont_restore_1(cont);
 }
+#ifdef __ia64
+#define cont_restore_0(cont, vp) register_stack_extend((cont), (vp), (VALUE*)rb_ia64_bsp())
+#endif
 
 /*
  *  Document-class: Continuation
diff -urN --exclude '*orig' ruby-3.1.5/dln.c ruby-3.1.5-ia64/dln.c
--- ruby-3.1.5/dln.c	2024-04-23 12:20:59.000000000 +0200
+++ ruby-3.1.5-ia64/dln.c	2024-05-30 11:18:37.568127732 +0200
@@ -208,7 +208,7 @@
 }
 #endif
 
-#if defined(_AIX)
+#if defined(_AIX) && ! defined(_IA64)
 static void
 aix_loaderror(const char *pathname)
 {
@@ -432,7 +432,7 @@
     }
 #endif /* hpux */
 
-#if defined(_AIX)
+#if defined(_AIX) && ! defined(_IA64)
 #define DLN_DEFINED
     {
 	void (*init_fct)(void);
diff -urN --exclude '*orig' ruby-3.1.5/ext/etc/etc.c ruby-3.1.5-ia64/ext/etc/etc.c
--- ruby-3.1.5/ext/etc/etc.c	2024-04-23 12:20:59.000000000 +0200
+++ ruby-3.1.5-ia64/ext/etc/etc.c	2024-05-30 11:18:37.576127733 +0200
@@ -788,6 +788,9 @@
 # ifndef PROCESSOR_ARCHITECTURE_AMD64
 #   define PROCESSOR_ARCHITECTURE_AMD64 9
 # endif
+# ifndef PROCESSOR_ARCHITECTURE_IA64
+#   define PROCESSOR_ARCHITECTURE_IA64 6
+# endif
 # ifndef PROCESSOR_ARCHITECTURE_INTEL
 #   define PROCESSOR_ARCHITECTURE_INTEL 0
 # endif
@@ -799,6 +802,9 @@
       case PROCESSOR_ARCHITECTURE_ARM:
 	mach = "ARM";
 	break;
+      case PROCESSOR_ARCHITECTURE_IA64:
+	mach = "IA64";
+	break;
       case PROCESSOR_ARCHITECTURE_INTEL:
 	mach = "x86";
 	break;
diff -urN --exclude '*orig' ruby-3.1.5/gc.c ruby-3.1.5-ia64/gc.c
--- ruby-3.1.5/gc.c	2024-04-23 12:20:59.000000000 +0200
+++ ruby-3.1.5-ia64/gc.c	2024-05-30 11:36:51.936322945 +0200
@@ -6110,7 +6110,11 @@
 
 /* Marking */
 
+#ifdef __ia64
+#define SET_STACK_END (SET_MACHINE_STACK_END(&ec->machine.stack_end), ec->machine.register_stack_end = rb_ia64_bsp())
+#else
 #define SET_STACK_END SET_MACHINE_STACK_END(&ec->machine.stack_end)
+#endif
 
 #define STACK_START (ec->machine.stack_start)
 #define STACK_END (ec->machine.stack_end)
@@ -6158,12 +6162,20 @@
 static int
 stack_check(rb_execution_context_t *ec, int water_mark)
 {
+    int ret;
     SET_STACK_END;
 
     size_t length = STACK_LENGTH;
     size_t maximum_length = STACK_LEVEL_MAX - water_mark;
 
-    return length > maximum_length;
+    ret = length > maximum_length;
+#ifdef __ia64
+    if (!ret) {
+        ret = (VALUE*)rb_ia64_bsp() - ec->machine.register_stack_start >
+           ec->machine.register_stack_maxsize/sizeof(VALUE) - water_mark;
+    }
+#endif
+    return ret;
 }
 #else
 #define stack_check(ec, water_mark) FALSE
@@ -6545,6 +6557,11 @@
 
     gc_mark_locations(objspace, stack_start, stack_end, cb);
 
+#ifdef __ia64
+    gc_mark_locations(objspace,
+                      ec->machine.register_stack_start,
+                      ec->machine.register_stack_end, cb);
+#endif
 #if defined(__mc68000__)
     gc_mark_locations(objspace,
 		      (VALUE*)((char*)stack_start + 2),
@@ -7697,6 +7714,14 @@
     return remembered_old_objects;
 }
 
+#undef Init_stack
+
+void
+Init_stack(volatile VALUE *addr)
+{
+    ruby_init_stack(addr);
+}
+
 /*
  *  call-seq:
  *     GC.verify_internal_consistency                  -> nil
diff -urN --exclude '*orig' ruby-3.1.5/gc.h ruby-3.1.5-ia64/gc.h
--- ruby-3.1.5/gc.h	2024-04-23 12:20:59.000000000 +0200
+++ ruby-3.1.5-ia64/gc.h	2024-05-30 11:40:09.200358132 +0200
@@ -18,9 +18,16 @@
 #define USE_CONSERVATIVE_STACK_END
 #endif
 
+#ifdef __ia64
+#define RB_GC_SAVE_MACHINE_REGISTER_STACK(th)          \
+    do{(th)->ec->machine.register_stack_end = rb_ia64_bsp();}while(0)
+#else
+#define RB_GC_SAVE_MACHINE_REGISTER_STACK(th)
+#endif
 #define RB_GC_SAVE_MACHINE_CONTEXT(th)				\
     do {							\
 	FLUSH_REGISTER_WINDOWS;					\
+        RB_GC_SAVE_MACHINE_REGISTER_STACK(th);			\
 	setjmp((th)->ec->machine.regs);				\
 	SET_MACHINE_STACK_END(&(th)->ec->machine.stack_end);	\
     } while (0)
diff -urN --exclude '*orig' ruby-3.1.5/ia64.S ruby-3.1.5-ia64/ia64.S
--- ruby-3.1.5/ia64.S	1970-01-01 01:00:00.000000000 +0100
+++ ruby-3.1.5-ia64/ia64.S	2024-05-30 11:18:37.592127736 +0200
@@ -0,0 +1,42 @@
+// rb_ia64_flushrs and rb_ia64_bsp is written in IA64 assembly language
+// because Intel Compiler for IA64 doesn't support inline assembly.
+//
+// This file is based on following C program compiled by gcc.
+//
+//   void rb_ia64_flushrs(void) { __builtin_ia64_flushrs(); }
+//   void *rb_ia64_bsp(void) { return __builtin_ia64_bsp(); }
+//
+// Note that rb_ia64_flushrs and rb_ia64_bsp works in its own stack frame.
+// It's because BSP is updated by br.call/brl.call (not alloc instruction).
+// So rb_ia64_flushrs flushes stack frames including caller's one.
+// rb_ia64_bsp returns the address next to caller's register stack frame.
+//
+// See also
+// Intel Itanium Architecture Software Developer's Manual
+// Volume 2: System Architecture.
+//
+	.file	"ia64.c"
+	.text
+	.align 16
+	.global rb_ia64_flushrs#
+	.proc rb_ia64_flushrs#
+rb_ia64_flushrs:
+	.prologue
+	.body
+	flushrs
+	;;
+	nop.i 0
+	br.ret.sptk.many b0
+	.endp rb_ia64_flushrs#
+	.align 16
+	.global rb_ia64_bsp#
+	.proc rb_ia64_bsp#
+rb_ia64_bsp:
+	.prologue
+	.body
+	nop.m 0
+	;;
+	mov r8 = ar.bsp
+	br.ret.sptk.many b0
+	.endp rb_ia64_bsp#
+	.ident	"GCC: (GNU) 3.3.5 (Debian 1:3.3.5-13)"
diff -urN --exclude '*orig' ruby-3.1.5/include/ruby/defines.h ruby-3.1.5-ia64/include/ruby/defines.h
--- ruby-3.1.5/include/ruby/defines.h	2024-04-23 12:20:59.000000000 +0200
+++ ruby-3.1.5-ia64/include/ruby/defines.h	2024-05-30 11:19:49.568140575 +0200
@@ -109,6 +109,10 @@
 void rb_sparc_flush_register_windows(void);
 RBIMPL_SYMBOL_EXPORT_END()
 # define FLUSH_REGISTER_WINDOWS rb_sparc_flush_register_windows()
+#elif defined(__ia64)
+void *rb_ia64_bsp(void);
+void rb_ia64_flushrs(void);
+# define FLUSH_REGISTER_WINDOWS rb_ia64_flushrs()
 #else
 # define FLUSH_REGISTER_WINDOWS ((void)0)
 #endif
diff -urN --exclude '*orig' ruby-3.1.5/include/ruby/internal/interpreter.h ruby-3.1.5-ia64/include/ruby/internal/interpreter.h
--- ruby-3.1.5/include/ruby/internal/interpreter.h	2024-04-23 12:20:59.000000000 +0200
+++ ruby-3.1.5-ia64/include/ruby/internal/interpreter.h	2024-05-30 11:22:22.408167838 +0200
@@ -67,6 +67,8 @@
  */
 void ruby_sysinit(int *argc, char ***argv);
 
+
+
 /**
  * Calls ruby_setup() and check error.
  *
@@ -141,7 +143,13 @@
  *
  * @param[in]  addr  A pointer somewhere on the stack, near its bottom.
  */
-void ruby_init_stack(volatile VALUE *addr);
+#ifdef __ia64
+void ruby_init_stack(volatile VALUE* addr, void* bsp);
+#define ruby_init_stack(addr) ruby_init_stack((addr), rb_ia64_bsp())
+#else
+void ruby_init_stack(volatile VALUE* addr);
+#endif
+#define Init_stack(addr) ruby_init_stack(addr)
 
 /**
  * Initializes the VM and builtin libraries.
diff -urN --exclude '*orig' ruby-3.1.5/thread.c ruby-3.1.5-ia64/thread.c
--- ruby-3.1.5/thread.c	2024-04-23 12:20:59.000000000 +0200
+++ ruby-3.1.5-ia64/thread.c	2024-05-30 11:43:47.988397160 +0200
@@ -340,7 +340,12 @@
 # define PRI_THREAD_ID "p"
 #endif
 
-NOINLINE(static int thread_start_func_2(rb_thread_t *th, VALUE *stack_start));
+#ifndef __ia64
+#define thread_start_func_2(th, st, rst) thread_start_func_2(th, st)
+#endif
+NOINLINE(static int thread_start_func_2(rb_thread_t *th, VALUE *stack_start,
+                                        VALUE *register_stack_start));
+
 void ruby_sigchld_handler(rb_vm_t *); /* signal.c */
 
 static void
@@ -633,6 +638,9 @@
 
     // The thread stack doesn't exist in the forked process:
     th->ec->machine.stack_start = th->ec->machine.stack_end = NULL;
+#ifdef __ia64
+    th->ec->machine.register_stack_start = th->ec->machine.register_stack_end = NULL;
+#endif
 
     rb_threadptr_root_fiber_terminate(th);
 }
@@ -777,7 +785,7 @@
 void rb_ec_clear_current_thread_trace_func(const rb_execution_context_t *ec);
 
 static int
-thread_start_func_2(rb_thread_t *th, VALUE *stack_start)
+thread_start_func_2(rb_thread_t *th, VALUE *stack_start, VALUE *register_stack_start)
 {
     STACK_GROW_DIR_DETECTION;
     enum ruby_tag_type state;
@@ -816,6 +824,9 @@
     rb_ec_initialize_vm_stack(th->ec, vm_stack, size);
     th->ec->machine.stack_start = STACK_DIR_UPPER(vm_stack + size, vm_stack);
     th->ec->machine.stack_maxsize -= size * sizeof(VALUE);
+#ifdef __ia64
+    th->ec->machine.register_stack_start = register_stack_start;
+#endif
 
     thread_debug("thread start (get lock): %p\n", (void *)th);
 
diff -urN --exclude '*orig' ruby-3.1.5/thread_pthread.c ruby-3.1.5-ia64/thread_pthread.c
--- ruby-3.1.5/thread_pthread.c	2024-04-23 12:20:59.000000000 +0200
+++ ruby-3.1.5-ia64/thread_pthread.c	2024-05-30 12:03:15.048605340 +0200
@@ -729,6 +729,51 @@
 #define STACKADDR_AVAILABLE 1
 #elif defined __HAIKU__
 #define STACKADDR_AVAILABLE 1
+#elif defined __ia64 && defined _HPUX_SOURCE
+#include <sys/dyntune.h>
+
+#define STACKADDR_AVAILABLE 1
+
+/*
+ * Do not lower the thread's stack to PTHREAD_STACK_MIN,
+ * otherwise one would receive a 'sendsig: useracc failed.'
+ * and a coredump.
+ */
+#undef PTHREAD_STACK_MIN
+
+#define HAVE_PTHREAD_ATTR_GET_NP 1
+#undef HAVE_PTHREAD_ATTR_GETSTACK
+
+/*
+ * As the PTHREAD_STACK_MIN is undefined and
+ * no one touches the default stacksize,
+ * it is just fine to use the default.
+ */
+#define pthread_attr_get_np(thid, attr) 0
+
+/*
+ * Using value of sp is very rough... To make it more real,
+ * addr would need to be aligned to vps_pagesize.
+ * The vps_pagesize is 'Default user page size (kBytes)'
+ * and could be retrieved by gettune().
+ */
+static int
+hpux_attr_getstackaddr(const pthread_attr_t *attr, void **addr)
+{
+    static uint64_t pagesize;
+    size_t size;
+
+    if (!pagesize) {
+	if (gettune("vps_pagesize", &pagesize)) {
+	    pagesize = 16;
+	}
+	pagesize *= 1024;
+    }
+    pthread_attr_getstacksize(attr, &size);
+    *addr = (void *)((size_t)((char *)_Asm_get_sp() - size) & ~(pagesize - 1));
+    return 0;
+}
+#define pthread_attr_getstackaddr(attr, addr) hpux_attr_getstackaddr(attr, addr)
 #endif
 
 #ifndef MAINSTACKADDR_AVAILABLE
@@ -828,6 +873,9 @@
     rb_nativethread_id_t id;
     size_t stack_maxsize;
     VALUE *stack_start;
+#ifdef __ia64
+    VALUE *register_stack_start;
+#endif
 } native_main_thread;
 
 #ifdef STACK_END_ADDRESS
@@ -909,10 +957,19 @@
 
 #undef ruby_init_stack
 void
-ruby_init_stack(volatile VALUE *addr)
+ruby_init_stack(volatile VALUE *addr
+#ifdef __ia64
+    , void *bsp
+#endif
+    )
 {
     native_main_thread.id = pthread_self();
-
+#ifdef __ia64
+    if (!native_main_thread.register_stack_start ||
+        (VALUE*)bsp < native_main_thread.register_stack_start) {
+        native_main_thread.register_stack_start = (VALUE*)bsp;
+    }
+#endif
 #if MAINSTACKADDR_AVAILABLE
     if (native_main_thread.stack_maxsize) return;
     {
@@ -1016,7 +1073,11 @@
 	rb_raise(rb_eNotImpError, "ruby engine can initialize only in the main thread");
 #endif
     }
-
+#ifdef __ia64
+    th->ec->machine.register_stack_start = native_main_thread.register_stack_start;
+    th->ec->machine.stack_maxsize /= 2;
+    th->ec->machine.register_stack_maxsize = th->ec->machine.stack_maxsize;
+#endif
     return 0;
 }
 
@@ -1044,9 +1105,9 @@
 	native_thread_init(th);
 	/* run */
 #if defined USE_NATIVE_THREAD_INIT
-        thread_start_func_2(th, th->ec->machine.stack_start);
+        thread_start_func_2(th, th->ec->machine.stack_start, rb_ia64_bsp());
 #else
-        thread_start_func_2(th, &stack_start);
+        thread_start_func_2(th, &stack_start, rb_ia64_bsp());
 #endif
     }
 #if USE_THREA_CACHE
@@ -1181,6 +1242,10 @@
         th->altstack = rb_allocate_sigaltstack();
 #endif
         th->ec->machine.stack_maxsize = stack_size - space;
+#ifdef __ia64
+        th->ec->machine.stack_maxsize /= 2;
+        th->ec->machine.register_stack_maxsize = th->ec->machine.stack_maxsize;
+#endif
 
 	CHECK_ERR(pthread_attr_init(&attr));
 
diff -urN --exclude '*orig' ruby-3.1.5/thread_win32.c ruby-3.1.5-ia64/thread_win32.c
--- ruby-3.1.5/thread_win32.c	2024-04-23 12:20:59.000000000 +0200
+++ ruby-3.1.5-ia64/thread_win32.c	2024-05-30 11:18:37.632127743 +0200
@@ -602,7 +602,7 @@
     thread_debug("thread created (th: %p, thid: %p, event: %p)\n", th,
 		 th->thread_id, th->native_thread_data.interrupt_event);
 
-    thread_start_func_2(th, th->ec->machine.stack_start);
+    thread_start_func_2(th, th->ec->machine.stack_start, rb_ia64_bsp());
 
     w32_close_handle(thread_id);
     thread_debug("thread deleted (th: %p)\n", th);
diff -urN --exclude '*orig' ruby-3.1.5/tool/m4/ruby_stack_grow_direction.m4 ruby-3.1.5-ia64/tool/m4/ruby_stack_grow_direction.m4
--- ruby-3.1.5/tool/m4/ruby_stack_grow_direction.m4	2024-04-23 12:20:59.000000000 +0200
+++ ruby-3.1.5-ia64/tool/m4/ruby_stack_grow_direction.m4	2024-05-30 11:18:37.636127744 +0200
@@ -3,7 +3,7 @@
     AS_VAR_PUSHDEF([stack_grow_dir], [rb_cv_stack_grow_dir_$1])
     AC_CACHE_CHECK(stack growing direction on $1, stack_grow_dir, [
 AS_CASE(["$1"],
-[m68*|x86*|x64|i?86|ppc*|sparc*|alpha*], [ $2=-1],
+[m68*|x86*|x64|i?86|ia64|ppc*|sparc*|alpha*], [ $2=-1],
 [hppa*], [ $2=+1],
 [
   AC_RUN_IFELSE([AC_LANG_SOURCE([[
diff -urN --exclude '*orig' ruby-3.1.5/vm.c ruby-3.1.5-ia64/vm.c
--- ruby-3.1.5/vm.c	2024-04-23 12:20:59.000000000 +0200
+++ ruby-3.1.5-ia64/vm.c	2024-05-30 11:18:37.644127745 +0200
@@ -3305,6 +3305,9 @@
 
 extern VALUE *rb_gc_stack_start;
 extern size_t rb_gc_stack_maxsize;
+#ifdef __ia64
+extern VALUE *rb_gc_register_stack_start;
+#endif
 
 /* debug functions */
 
diff -urN --exclude '*orig' ruby-3.1.5/vm_core.h ruby-3.1.5-ia64/vm_core.h
--- ruby-3.1.5/vm_core.h	2024-04-23 12:20:59.000000000 +0200
+++ ruby-3.1.5-ia64/vm_core.h	2024-05-30 11:18:37.652127746 +0200
@@ -966,6 +966,11 @@
 	VALUE *stack_start;
 	VALUE *stack_end;
 	size_t stack_maxsize;
+#ifdef __ia64
+	VALUE *register_stack_start;
+	VALUE *register_stack_end;
+	size_t register_stack_maxsize;
+#endif
 	RUBY_ALIGNAS(SIZEOF_VALUE) jmp_buf regs;
     } machine;
 };
diff -urN --exclude '*orig' ruby-3.1.5/vm_dump.c ruby-3.1.5-ia64/vm_dump.c
--- ruby-3.1.5/vm_dump.c	2024-04-23 12:20:59.000000000 +0200
+++ ruby-3.1.5-ia64/vm_dump.c	2024-05-30 11:18:37.656127747 +0200
@@ -701,6 +701,14 @@
 		    frame.AddrFrame.Offset = context.Rbp;
 		    frame.AddrStack.Mode = AddrModeFlat;
 		    frame.AddrStack.Offset = context.Rsp;
+#elif defined(_M_IA64) || defined(__ia64__)
+		    mac = IMAGE_FILE_MACHINE_IA64;
+		    frame.AddrPC.Mode = AddrModeFlat;
+		    frame.AddrPC.Offset = context.StIIP;
+		    frame.AddrBStore.Mode = AddrModeFlat;
+		    frame.AddrBStore.Offset = context.RsBSP;
+		    frame.AddrStack.Mode = AddrModeFlat;
+		    frame.AddrStack.Offset = context.IntSp;
 #else	/* i386 */
 		    mac = IMAGE_FILE_MACHINE_I386;
 		    frame.AddrPC.Mode = AddrModeFlat;
diff -urN --exclude '*orig' ruby-3.1.5/win32/Makefile.sub ruby-3.1.5-ia64/win32/Makefile.sub
--- ruby-3.1.5/win32/Makefile.sub	2024-04-23 12:20:59.000000000 +0200
+++ ruby-3.1.5-ia64/win32/Makefile.sub	2024-05-30 11:37:57.340334611 +0200
@@ -397,7 +397,7 @@
 DTRACE_EXT = dmyh
 
 !if !defined(STACK)
-!if "$(ARCH)" == "x64"
+!if "$(ARCH)" == "x64" || "$(ARCH)" == "ia64"
 STACK = 0x400000
 !else
 STACK = 0x200000
@@ -676,7 +676,7 @@
 #define NUM2CLOCKID(v) NUM2INT(v)
 #define SIZEOF_CLOCK_T 4
 #define SIZEOF_RLIM_T 0
-!if "$(ARCH)" == "x64"
+!if "$(ARCH)" == "x64" || "$(ARCH)" == "ia64" || "$(ARCH)" == "ia64"
 #define SIZEOF_SIZE_T 8
 #define SIZEOF_PTRDIFF_T 8
 #define SIZEOF_INTPTR_T 8
@@ -717,7 +717,7 @@
 !else
 #define PACKED_STRUCT(x) x
 !endif
-!if "$(MACHINE)" == "x86" || "$(ARCH)" == "x64"
+!if "$(MACHINE)" == "x86" || "$(ARCH)" == "x64"  || "$(ARCH)" == "ia64"
 #define PACKED_STRUCT_UNALIGNED(x) PACKED_STRUCT(x)
 !else
 #define PACKED_STRUCT_UNALIGNED(x) x
@@ -782,7 +782,7 @@
 #define HAVE_INTPTR_T 1
 #define HAVE_UINTPTR_T 1
 #define HAVE_SSIZE_T 1
-!if "$(ARCH)" == "x64"
+!if "$(ARCH)" == "x64" || "$(ARCH)" == "ia64"
 #define ssize_t __int64
 #define PRI_PTR_PREFIX "I64"
 !else
@@ -876,7 +876,7 @@
 !endif
 #endif
 #define NEED_IO_SEEK_BETWEEN_RW 1
-!if "$(MACHINE)" == "x86" || "$(ARCH)" == "x64"
+!if "$(MACHINE)" == "x86" || "$(ARCH)" == "x64" || "$(ARCH)" == "ia64"
 #define STACK_GROW_DIRECTION -1
 !endif
 #define COROUTINE_H "$(COROUTINE_H)"
diff -urN --exclude '*orig' ruby-3.1.5/win32/README.win32 ruby-3.1.5-ia64/win32/README.win32
--- ruby-3.1.5/win32/README.win32	2024-04-23 12:20:59.000000000 +0200
+++ ruby-3.1.5-ia64/win32/README.win32	2024-05-30 11:18:37.668127749 +0200
@@ -8,8 +8,8 @@
 
 2.  Visual C++ 12.0 (2013) or later.
 
-    [Note] if you want to build x64 version, use native compiler for
-           x64.
+    [Note] if you want to build x64 or ia64 version, use native compiler for
+           x64/ia64.
 
 3.  Please set environment variable +INCLUDE+, +LIB+, +PATH+
     to run required commands properly from the command line.
diff -urN --exclude '*orig' ruby-3.1.5/win32/configure.bat ruby-3.1.5-ia64/win32/configure.bat
--- ruby-3.1.5/win32/configure.bat	2024-04-23 12:20:59.000000000 +0200
+++ ruby-3.1.5-ia64/win32/configure.bat	2024-05-30 11:18:37.668127749 +0200
@@ -101,7 +101,8 @@
 :target
   echo>> ~tmp~.mak 	"%~2" \
   echo>>confargs.tmp --target=%2 \
-  if NOT "%~2" == "x64-mswin64" goto target3
+  if "%~2" == "x64-mswin64" goto target2
+  if NOT "%~2" == "ia64-mswin64" goto target3
 :target2
   echo>> ~tmp~.mak 	"TARGET_OS=mswin64" \
 :target3
diff -urN --exclude '*orig' ruby-3.1.5/win32/setup.mak ruby-3.1.5-ia64/win32/setup.mak
--- ruby-3.1.5/win32/setup.mak	2024-04-23 12:20:59.000000000 +0200
+++ ruby-3.1.5-ia64/win32/setup.mak	2024-05-30 11:18:37.668127749 +0200
@@ -30,6 +30,7 @@
 i686-mswin32: -prologue- -i686- -epilogue-
 alpha-mswin32: -prologue- -alpha- -epilogue-
 x64-mswin64: -prologue- -x64- -epilogue-
+ia64-mswin64: -prologue- -ia64- -epilogue-
 
 -prologue-: -basic-vars-
 -generic-: -osname-
@@ -187,6 +188,8 @@
 	@$(CPP) <<conftest.c 2>nul | findstr = >>$(MAKEFILE)
 #if defined _M_X64
 MACHINE = x64
+#elif defined _M_IA64
+MACHINE = ia64
 #else
 MACHINE = x86
 #endif
@@ -199,6 +202,8 @@
 	@echo MACHINE = alpha>>$(MAKEFILE)
 -x64-: -osname64-
 	@echo MACHINE = x64>>$(MAKEFILE)
+-ia64-: -osname64-
+	@echo MACHINE = ia64>>$(MAKEFILE)
 -ix86-: -osname32-
 	@echo MACHINE = x86>>$(MAKEFILE)
 
